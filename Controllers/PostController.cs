using AutoMapper;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using SeeSay.Exceptions;
using SeeSay.Models.Dto.Posts;
using SeeSay.Models.Entities;
using SeeSay.Services.Abstractions;
using SeeSay.Utils.Extensions;

namespace SeeSay.Controllers;

[Route(template: "api/[controller]/[action]")]
[ApiController]
public class PostController : ControllerBase
{
    private readonly IPostRepository postRepository;
    private readonly UserManager<User> userManager;
    private readonly IMapper mapper;
    private readonly ILogger<PostController> logger;

    public PostController(IPostRepository postRepository,
        UserManager<User> userManager,
        IMapper mapper,
        ILoggerFactory loggerFactory)
    {
        this.postRepository = postRepository;
        this.userManager = userManager;
        this.mapper = mapper;
        logger = loggerFactory.CreateLogger<PostController>();
    }

    [HttpGet("{pageSize}")]
    public async Task<IActionResult> GetNumberOfPostPages([FromRoute] int pageSize = 21)
    {
        return Ok(await postRepository.GetNumberOfPostPages(pageSize));
    }

    [HttpGet("{userId}")]
    public async Task<IActionResult> GetNumberOfUserPosts([FromRoute] string userId)
    {
        return Ok(await postRepository.GetNumberOfUserPosts(userId));
    }

    [HttpPost]
    public async Task<IActionResult> GetPosts(
        [FromBody(EmptyBodyBehavior = EmptyBodyBehavior.Allow)] FilterOptions? filterOptions = null)
    {
        IEnumerable<LightweightPostDto> posts;

        if (filterOptions is not null)
        {
            if (filterOptions.Likes is not null)
                posts = await postRepository.GetLightweightLikedPostsAsync(filterOptions.Likes,
                    filterOptions.Page, filterOptions.PageSize);
            else if (!string.IsNullOrWhiteSpace(filterOptions.UserId))
                posts = await postRepository.GetLightweightUserPostsAsync(filterOptions.UserId,
                    filterOptions.Page, filterOptions.PageSize);
            else if (filterOptions.CategoryId.HasValue)
                posts = await postRepository.GetLightweightCategoryPostsAsync(
                    filterOptions.CategoryId.Value, filterOptions.Page,
                    filterOptions.PageSize);
            else if (!string.IsNullOrWhiteSpace(filterOptions.Search))
                posts = await postRepository.GetLightweightPostsAsync(filterOptions.Search,
                    filterOptions.Page, filterOptions.PageSize);
            else
                posts = await postRepository.GetLightweightPostsAsync(page: filterOptions.Page,
                    pageSize: filterOptions.PageSize);
        }
        else
        {
            posts = await postRepository.GetLightweightPostsAsync();
        }


        return Ok(posts);
    }

    [HttpGet("{id:int}")]
    public async Task<IActionResult> GetPost([FromRoute] int id)
    {
        FullPostDto post;
        try
        {
            post = await postRepository.GetAsync(id);
        }
        catch (EntityNotFoundException)
        {
            return NotFound();
        }

        return Ok(post);
    }

    [HttpPost]
    [Authorize]
    public async Task<IActionResult> CreatePost([FromForm] PostCreateDto postDto,
        [FromForm] IFormFile image,
        [FromServices] IHttpClientFactory httpClientFactory)
    {
        var currentUserId = User.GetCurrentUserId();
        var post = mapper.Map<PostCreateDto, Post>(postDto);
        post.UserId = currentUserId;
        await postRepository.AddAsync(post);

        using var httpClient = httpClientFactory.CreateClient("AzureFunctionClient");
        await using var imageStream = image.OpenReadStream();
        using var content = new MultipartFormDataContent();
        content.Add(new StreamContent(imageStream), "image", image.FileName);
        content.Add(new StringContent(post.Id.ToString()), "PostId");
        content.Add(new StringContent(currentUserId), "UserId");
        content.Add(new StringContent(postDto.SignalConnectionId), "SignalConnectionId");
        content.Add(new StringContent(string.IsNullOrWhiteSpace(postDto.Description)
            .ToString()), "ShouldAutoGenerateDescription");

        logger.LogInformation("[POST] UploadImages: sending uploaded image to Azure Function check");
        var response = await httpClient.PostAsync($"/api/check", content);

        imageStream.Close();
        if (!response.IsSuccessStatusCode)
        {
            logger.LogWarning(
                "[POST] UploadImages: azure function check doesnt return success status code, returning 400 Bad Request");
            return BadRequest(response);
        }

        return CreatedAtAction(actionName: nameof(GetPost), controllerName: "Post",
            routeValues: post.Id, value: post);
    }

    [HttpDelete("{id:int}")]
    [Authorize]
    public async Task<IActionResult> DeletePost([FromRoute] int id)
    {
        var post = await postRepository.GetAsync(id);
        if (post.UserId != User.GetCurrentUserId() && !User.IsInRole("Moderator"))
        {
            return Forbid();
        }

        await postRepository.DeleteAsync(id);
        return Ok();
    }

    [HttpGet("{id:int}")]
    [AllowAnonymous]
    public async Task<IActionResult> DownloadPost([FromRoute] int id)
    {
        var post = await postRepository.GetAsync(id);
        if (post is null)
            throw new EntityNotFoundException();

        var currentUser = await User.GetCurrentUserFromManagerAsync(userManager);
        if (post.IsPremium && !currentUser.HasPremium)
            return BadRequest();
        
        using var client = new HttpClient();
        var response = await client.GetAsync(post.ImagePath);
        var extension = Path.GetExtension(post.ImagePath);


        if (response.IsSuccessStatusCode)
        {
            var stream = await response.Content.ReadAsStreamAsync();
            await postRepository.IncrementNumberOfDownloads(id);
            Console.WriteLine(extension);
            return File(stream, response.Content.Headers.ContentType?.ToString() ?? "image/*",
                post.Description + extension);
        }


        return BadRequest();
    }
}